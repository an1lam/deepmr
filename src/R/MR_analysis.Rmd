---
title: "Mendelian Randomization analysis of DeepSEA generated data"
output: html_notebook
params:
  cell_type: "HepG2"
  tf: "FOXA1"
  output_dir: "../../fig/R/"
  save_plots: T
---
```{r}
library(MendelianRandomization)
library(dplyr)
library(ks)
library(tidyverse)
library(ggplot2)
library(stringr)
```

First let's load our data into a dataframe. This dataframe has 5 non-null columns: 
1. `seq_num`: Index of the DNA sequence from which the effect sizes and standard errors come.
2. `X_pred_mean`: Effect size for the \( Z \rightarrow X \) relationship. Determined by taking the difference between predicted transcription factor binding probability for a reference sequence and a mutated version of the reference.
3. `X_pred_var`: Standard error of the \( Z \rightarrow X \) effect size estimate.
4. `Y_pred_mean`: Effect size for the \( Z \rightarrow Y \) relationship. Determined by taking the difference between predicted chromatin accessibility probability for a reference sequence and a mutated version of the reference.
5. `Y_pred_var`: Standard error of the \( Z \rightarrow Y \) effect size estimate.

```{r}
data_dir <- "../../dat/"
results_dir <- "../../dat/res-repro/"
tf <- params$tf
cell_type <- params$cell_type

results_fname <- str_c(cell_type, tf, "mutagenesis_results.csv", sep = "_")
seq_predictions <- read.csv(file.path(results_dir, results_fname))
is.nan.data.frame <- function(x) {
  do.call(cbind, lapply(x, is.nan))
}

seq_predictions
n_seqs <- max(seq_predictions["seq_num"])
print(str_c("Running on ", n_seqs, " sequences' predictions for tf ", tf))
```


```{r}
ivw_vals <- list()
egger_vals <- list()

egger_result <- matrix(ncol = 8, nrow = n_seqs)
plots <- c()

for (seq in (1:n_seqs)) {
  seq_i_predictions <- subset(seq_predictions, seq_num == seq)

  bxt <- unlist(seq_i_predictions["X_pred_mean"])
  bxset <- unlist(seq_i_predictions["X_pred_var"])
  byt <- unlist(seq_i_predictions["Y_pred_mean"])
  byset <- unlist(seq_i_predictions["Y_pred_var"])
  MRInputObject <- mr_input(
    bx = bxt,
    bxse = bxset,
    by = byt,
    byse = byset
  )
  EggerObject <- mr_egger(MRInputObject)
  plots <- c(plots, mr_plot(MRInputObject))
  egger_result[seq, ] <- c(
    EggerObject$Estimate,
    EggerObject$CILower.Est,
    EggerObject$CIUpper.Est,
    EggerObject$I.sq,
    EggerObject$Pleio.pval,
    EggerObject$StdError.Est,
    EggerObject$Intercept,
    EggerObject$Pvalue.Est
  )
}

colnames(egger_result) <- c(
  "ce",
  "cil",
  "ciu",
  "i.sq",
  "pleio",
  "std",
  "int",
  "pval"
)
egger_result <- as_tibble(egger_result)
```

```{r}
# egger_result$int
# egger_result$pleio
egger_result$pval
egger_result$cil
egger_result$ciu
```

Now we have the causal effect estimates, confidence intervals, and (for Egger) pleiotropy p-values.
```{r}
egger_result
```

Let's summarize the IVW & Egger causal effect estimates as histograms. This will give us an idea of how heterogeneous the alleged causal relationships are at different regions of the genome.
```{r}
d <- density(egger_result$ce)
ce_smoothed <- ks::kde(
  x = egger_result$ce,
  binned = TRUE,
  compute.cont = TRUE,
  xmin = c(min(egger_result$ce) - 1),
  xmax = c(max(egger_result$ce) + 1),
  bgridsize = c(200)
)

if (params$save_plots) {
  output_fname <- str_c(cell_type, tf, "ces_kde.png", sep = "_")
  output_fpath <- file.path(params$output_dir, output_fname)
  png(output_fpath, width = 512, height = 320)
  par(mar = c(5, 6, 5, 1) + .1)
}
plot(
  ce_smoothed,
  xlab = "Causal Effect",
  # main = str_c("Causal Effect Estimates (", tf, ")"),
  cex.lab = 2,
  cex.main = 2,
  ylab = "Density"
)
if (params$save_plots) {
  dev.off()
}
```

```{r}
sorted_idxs <- sort(egger_result$ce, index.return=TRUE)$ix
median_idx <- as.integer(length(sorted_idxs) / 2) + 1
seq_median_preds <- subset(seq_predictions, seq_num == median_idx)

bxt <- unlist(seq_median_preds["X_pred_mean"])
bxset <- unlist(seq_median_preds["X_pred_var"])
byt <- unlist(seq_median_preds["Y_pred_mean"])
byset <- unlist(seq_median_preds["Y_pred_var"])

MRInputObject <- mr_input(
  bx = bxt,
  bxse = bxset,
  by = byt,
  byse = byset
)
MedianEggerObj <- mr_egger(MRInputObject)
```


```{r}
mr_plot(MRInputObject, line="egger")
```


```{r}

if (params$save_plots) {
  png(file.path(params$output_dir, output_fname), width = 512, height = 320)
}
par(mfrow=c(2, 2))

for (seq in (1:n_seqs)) {
  seq_i_predictions <- subset(seq_predictions, seq_num == seq)

  bxset <- unlist(seq_i_predictions["X_pred_var"])
  byset <- unlist(seq_i_predictions["Y_pred_var"])
  
  plot(bxset, byset, main = str_c("CA vs. TF std error"))
}

if (params$save_plots) {
  dev.off()
}
```

```{r}
dmode <- function(x) {
  den <- density(x, kernel = c("gaussian"))
  (den$x[den$y == max(den$y)])
}
dmode(egger_result$ce)
median(egger_result$ce)
length(egger_result$ce[egger_result$ce < 0])
length(egger_result$ce)
```

Let's also look at the distribution of pleiotropy p-values for different sequences. If they're concentrated around .5, this means that the algorithm believes there to be very little pleiotropy.

```{r}
qplot(pleio, data = egger_result, binwidth = .04)
```

```{r}
p <- ggplot2::ggplot(egger_result, aes(x = ce, y = std)) +
  geom_point()
p
```

```{r}
if (params$save_plots) {
  output_fname <- str_c(cell_type, tf, "ex_eff_sizes.png", sep = "_")
  output_fpath <- file.path(params$output_dir, output_fname)
  png(output_fpath, width = 512, height = 320)
  par(mar = c(5, 6, 5, 1) + .1)
}

plot(bxt, byt, xlab="FOXA1 Effect Sizes", ylab="Chromatin Accessibility Effect Sizes")

if (params$save_plots) {
  dev.off()
}
```
